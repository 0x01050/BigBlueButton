<?xml version="1.0" encoding="utf-8"?>

<!--
  BigBlueButton open source conferencing system - http://www.bigbluebutton.org
  
  Copyright (c) 2010 BigBlueButton Inc. and by respective authors (see below).
  
  BigBlueButton is free software; you can redistribute it and/or modify it under the 
  terms of the GNU Lesser General Public License as published by the Free Software 
  Foundation; either version 2.1 of the License, or (at your option) any later 
  version. 
  
  BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY 
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
  PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License along 
  with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 
  $Id: $
-->

<mx:VBox xmlns:mx="http://www.adobe.com/2006/mxml"
		 xmlns:mate="http://mate.asfusion.com/"
		 creationComplete="onCreationComplete()"
		 xmlns:flexlib="http://code.google.com/p/flexlib/"
		 width="100%" height="100%" xmlns:containers="flexlib.containers.*"
		 implements="org.bigbluebutton.common.IUserListener"
		 verticalScrollPolicy="off">
	
	<mate:Listener type="{PrivateChatMessageEvent.PRIVATE_CHAT_MESSAGE_EVENT}" method="handlePrivateChatMessageEvent"/>
	<mate:Listener type="{PublicChatMessageEvent.PUBLIC_CHAT_MESSAGE_EVENT}" method="handlePublicChatMessageEvent"/>
	<mate:Listener type="{BBBEvent.SEND_PUBLIC_CHAT_MESSAGE_EVENT}" method="sendMessageReceivedFromBBBEvent"/> 
	<mate:Listener type="{ChatOptionsEvent.CHANGE_FONT_SIZE}" method="changeFontSize" />
	<mate:Listener type="{ChatOptionsEvent.TOGGLE_TRANSLATE}" method="toggleTranslation" />
	
	<mate:Listener type="{ShortcutEvent.FOCUS_PREV_CHAT_TAB}" method="focusPreviousChatTab" />
	<mate:Listener type="{ShortcutEvent.FOCUS_NEXT_CHAT_TAB}" method="focusNextChatTab" />
	
	
	<mx:Style>
		.chatColorPickerStyle {
			backgroundColor:#E5E6E7;
			columnCount:12;
			horizontalGap:0;
			previewHeight:22;
			previewWidth:45;
			swatchGridBackgroundColor:#000000;
			swatchGridBorderSize:0;
			swatchHeight:60;
			swatchHighlightColor:#FFFFFF;
			swatchHighlightSize:1;
			swatchWidth:12;
			textFieldWidth:72;
			verticalGap:0;
		}
		
	</mx:Style>
	
	<mx:Script>
		<![CDATA[
            import be.boulevart.google.ajaxapi.translation.GoogleTranslation;
            import be.boulevart.google.events.GoogleApiEvent;           
            import com.asfusion.mate.events.Dispatcher;            
            import flash.external.ExternalInterface;            
            import flexlib.controls.tabBarClasses.SuperTab;
            import flexlib.controls.textClasses.StringBoundaries;
            import flexlib.events.SuperTabEvent;
            import flexlib.mdi.containers.MDIWindow;            
            import mx.collections.ArrayCollection;
            import mx.containers.ControlBar;
            import mx.controls.Button;
            import mx.core.Container;
            import mx.core.UIComponent;
            import mx.events.IndexChangedEvent;           
            import org.bigbluebutton.common.IUserListener;
            import org.bigbluebutton.common.LogUtil;
            import org.bigbluebutton.core.BBB;
            import org.bigbluebutton.core.managers.UserManager;
            import org.bigbluebutton.main.events.BBBEvent;
            import org.bigbluebutton.main.events.ParticipantJoinEvent;
            import org.bigbluebutton.main.model.User;
            import org.bigbluebutton.modules.chat.events.ChatOptionsEvent;
            import org.bigbluebutton.modules.chat.events.PrivateChatMessageEvent;
            import org.bigbluebutton.modules.chat.events.PublicChatMessageEvent;
            import org.bigbluebutton.modules.chat.events.QueryParticipantsEvent;
            import org.bigbluebutton.modules.chat.events.SendPrivateChatMessageEvent;
            import org.bigbluebutton.modules.chat.events.SendPublicChatMessageEvent;
            import org.bigbluebutton.modules.chat.model.ChatObject;
            import org.bigbluebutton.modules.chat.model.ChatOptions;
            import org.bigbluebutton.modules.chat.model.MessageVO;
            import org.bigbluebutton.modules.chat.model.business.UserVO;
            import org.bigbluebutton.util.i18n.ResourceUtil;
			import flash.utils.Timer;
			import flash.events.FocusEvent;  
			import org.bigbluebutton.main.events.ShortcutEvent;
			import flash.media.Sound;
    		import flash.media.SoundChannel;
			
			[Bindable] public var colorPickerColours:Array = ['0x000000', '0x7A7A7A' ,'0xFF0000', '0xFF8800',
				'0x88FF00', '0x00FF00', '0x00FF88', '0x00FFFF', '0x0088FF', '0x0000FF', '0x8800FF', '0xFF00FF'];
			
			private static const PUBLIC_CHAT_USERID:String = '0';
			private static const PUBLIC_CHAT_USERNAME:String = ResourceUtil.getInstance().getString("bbb.chat.publicChatUsername");			
			private static const TAB_BOX_ID:String = '+';
			private var tabBox:AddChatTabBox;			
			private var focus:Boolean = true;			
			private var globalDispatcher:Dispatcher = new Dispatcher();			
			private var autoTranslation:Boolean=false;
			[Bindable] public var chatOptions:ChatOptions;
			
			[Bindable]
			public var participants:ArrayCollection = new ArrayCollection();
			
            public var chatWindow:ChatWindow;
			
			// Descriptions for accessibilty properties
			// private static const PUBLIC_TAB:String = "PUBLIC CHAT";
			private static const PUBLIC_TAB:String = "JAWS is cumbersome";
			private static const PUBLIC_TAB_NEW:String = "NEW MESSAGE IN PUBLIC CHAT";
			private static const PRIVATE_TAB:String = "PRIVATE CHAT WITH ";
			private static const PRIVATE_TAB_NEW:String = "NEW MESSAGE IN PRIVATE CHAT WITH ";
			private static const PLUS_TAB:String = "CHAT OPTIONS TAB";
            
			private var publicWaiting:Boolean = false;
			private var privateWaiting:ArrayCollection = new ArrayCollection();
			private var timerInterval:int = 10; // How many seconds you want the timer to wait between chat notifications
            private var notificationTimer:Timer = new Timer(timerInterval * 1000);
			
			[Embed(source="../sounds/publicSound.mp3")] private var publicSoundClass:Class;
			[Embed(source="../sounds/privateSound.mp3")] private var privateSoundClass:Class;
			private var publicSound:Sound = new publicSoundClass() as Sound;
			private var privateSound:Sound = new privateSoundClass() as Sound;		
			
			private function onCreationComplete():void{
				// Start the timer for screen-reader-friendly chat notifications
				notificationTimer.addEventListener(TimerEvent.TIMER, checkNotifications);
				notificationTimer.start();
				
				addParticipantToList(PUBLIC_CHAT_USERID, PUBLIC_CHAT_USERNAME, "public");
				openChatBoxFor(PUBLIC_CHAT_USERID);
				createAddTabBox();
				makePublicChatUncloseable();
				addEventListener(SuperTabEvent.TAB_CLOSE, onUserClosedTab);
				systemManager.stage.addEventListener(Event.MOUSE_LEAVE, mouseLeave);
				systemManager.stage.addEventListener(Event.ACTIVATE, activate);
				systemManager.stage.addEventListener(Event.DEACTIVATE, deactivate);

				
				UserManager.getInstance().registerListener(this);
				
				registerExternalListener();
			}       
			
			private function registerExternalListener():void{
				ExternalInterface.addCallback('sendChatMessage', setChatMessage);
			}
			
			private function setChatMessage(message:String):void{
                chatWindow.txtMsg.text += message;
			}
			
			private function setColor():void{
				var r:int = Math.round(Math.random() * 12);
                chatWindow.cmpColorPicker.selectedIndex = r;
			}
			
			private function mouseLeave(event:Event):void{
				this.focus = false;
			}
			
			private function activate(event:Event):void{
				ExternalInterface.call("clearblink");
				this.focus = true;
			}
			
			private function deactivate(event:Event):void{
				this.focus = false;
			}
			
			private function sendMessageReceivedFromBBBEvent(event:BBBEvent):void {
                chatWindow.txtMsg.text = event.message;
				sendMessages();
			}
			
			private function makePublicChatUncloseable():void {
				// See definition of callLater on Adobe Flash doc.
				callLater(calledOnTheNextScreenRefresh);
			}
			
			private function calledOnTheNextScreenRefresh():void {
				var chatBox:ChatBox = getChatBoxForParticipant(PUBLIC_CHAT_USERID);
				var chatIndex:int = getTabIndexFor(chatBox);
				chatTabs.setClosePolicyForTab(chatIndex, SuperTab.CLOSE_NEVER);
				
				chatTabs.setClosePolicyForTab(chatTabs.getChildIndex(tabBox), SuperTab.CLOSE_NEVER);
			}
			
			public function setFocusOn(component:UIComponent):void {
				if (component.id == "txtMsg") {
					component.setFocus();
					component.drawFocus(true);
				}
				else {
                    chatWindow..txtMsg.setFocus();
                    chatWindow..txtMsg.drawFocus(true);
				}
			}
			
			public function setFocusOff():void {
                chatWindow..txtMsg.drawFocus(false);
			}
			
			private function currentTime() : String {
				return ChatBox.getHours() + ":" + ChatBox.getMinutes();
			}
			
			public function sendMessages():void {
				if (hasMessageToSend()){				
					if (isChatBoxCurrentlySelected(PUBLIC_CHAT_USERID)) {						
						sendPublicChatMessage(chatWindow.txtMsg.text);
					} else{						
						sendPrivateChatMessage();
					}
					clearMessageEntryTextBox();
				}
			}			
			
			private function hasMessageToSend():Boolean {
				return chatWindow.txtMsg.text != "";
                
                return false;
			}
			
			private function clearMessageEntryTextBox():void {
                chatWindow.txtMsg.text = "";
			}
			
			private function cleanup(message:String):String{
				var parsedString:String = message.replace('<', '&#60;')
				parsedString = parsedString.replace('>', '&#62;')
				
				return parsedString;
			}
			
			private function parseURLs(message:String):String{
				var indexOfHTTP:Number = message.indexOf("http://");
				var indexOfWWW:Number = message.indexOf("www.");
				if (indexOfHTTP == -1 && indexOfWWW == -1) return message;
				
				var words:Array = message.split(" ");
				var parsedString:String = "";
				
				for (var n:Number = 0; n<words.length; n++){
					var word:String = words[n] as String;
					if (word.indexOf("http://") != -1) parsedString += '<a href="event:' + word + '"> <u>' + word + '</u></a> ';
					else if (word.indexOf("www.") != -1) parsedString += '<a href="event:http://' + word + '"> <u>' + word + '</u></a> ';
					else parsedString += word + ' ';
				}
				return parsedString;
			}
			
			private function sendPublicChatMessage(message:String):void {
				var publicEvent:SendPublicChatMessageEvent = new SendPublicChatMessageEvent(SendPublicChatMessageEvent.SEND_PUBLIC_CHAT_MESSAGE_EVENT);
				publicEvent.message = parseURLs(cleanup(message));
				publicEvent.color = chatWindow.cmpColorPicker.selectedColor.toString();
				publicEvent.time = currentTime();
				publicEvent.language = ResourceUtil.getInstance().getCurrentLanguageCode().split("_")[0];
				globalDispatcher.dispatchEvent(publicEvent);
			}
			
			private function queryForParticipants():void {
				var event:QueryParticipantsEvent = new QueryParticipantsEvent(QueryParticipantsEvent.QUERY_PARTICIPANTS_EVENT);
				globalDispatcher.dispatchEvent(event);
			}
			
			private function sendPrivateChatMessage():void {
				var privateEvent:SendPrivateChatMessageEvent = new SendPrivateChatMessageEvent(SendPrivateChatMessageEvent.SEND_PRIVATE_CHAT_MESSAGE_EVENT);
				privateEvent.message = parseURLs(cleanup(chatWindow.txtMsg.text));
				privateEvent.toUser = chatTabs.selectedChild.name;
				privateEvent.color = chatWindow.cmpColorPicker.selectedColor.toString();
				privateEvent.time = currentTime();
				privateEvent.language = ResourceUtil.getInstance().getCurrentLanguageCode().split("_")[0];
				globalDispatcher.dispatchEvent(privateEvent);
			}
			
			private function isChatBoxCurrentlySelected(id:String):Boolean {
				if (chatTabs.getChildByName(id) == chatTabs.selectedChild){
					return true;
				}
				return false;
			}
			
			private function addParticipantToList(userid:String, name:String, role:String):void {
				var item:Object = new Object();
				item.label = name;
				item.userid = userid;
				item.role = role;
				participants.addItem(item);
			}
			
			private function removeParticipantFromList(userid:String):void {
				for (var i:Number = 0; i<participants.length; i++){
					if (participants.getItemAt(i).userid == userid) {
						participants.removeItemAt(i);
						updateChatBoxThatParticipantHasLeft(userid);
					}
				}
			}
			
			private function updateChatBoxThatParticipantHasLeft(userid:String):void {
				if (participantHasChatBox(userid)) {
					var chatBox:ChatBox = getChatBoxForParticipant(userid);
					chatBox.participantLoggedOut = true;
					
					if (isChatBoxCurrentlySelected(userid)) {
						disableMessageEntryTextBox();
					}
				}
			}
			
			private function notifyParticipantOfUnreadMessageFrom(userid:String):void {
				var chatBox:ChatBox = getChatBoxForParticipant(userid);
				var tabIndex:int = getTabIndexFor(chatBox);
				var tab:Button = chatTabs.getTabAt(tabIndex);
				tab.setStyle("fillColors", new Array(0xFFAE00, 0xD3800A));
				tab.setStyle("fillAlphas", new Array(1.0, 0.8));
			}
			
			private function getTabIndexFor(chatBox:ChatBox):int {
				return chatTabs.getChildIndex(chatBox);
			}
			
			private function onTabNavChange():void{
				var tab:Button = chatTabs.getTabAt(chatTabs.selectedIndex);
				tab.setStyle("fillColors", new Array(0xFFFFFF, 0xCCCCCC));
				
				if (chatTabs.selectedIndex == chatTabs.numChildren-1) {
					openAddChatTabBox();
					return;
				}
				
                chatWindow.txtMsg.enabled = true;
				var chatBox:ChatBox = chatTabs.getChildAt(chatTabs.selectedIndex) as ChatBox;
				if (chatBox.participantLoggedOut) {
					disableMessageEntryTextBox();
				} else {
					enableMessageEntryTextBox();
				}		
			}
			
			private function openAddChatTabBox():void{
                chatWindow.txtMsg.enabled = false;
			}
			
			private function getParticipantName(userid:String):String{
				for (var i:Number = 0; i<participants.length; i++){
					if (participants.getItemAt(i).userid == userid) return participants.getItemAt(i).label;
				}
				return "unknown user";
			}
			
			
			public function openChatBoxFor(userid:String):void {
				LogUtil.debug("Opening chat box " + userid);
				var chatBox:ChatBox;
				
				if (participantHasChatBox(userid)) {
					chatBox = getChatBoxForParticipant(userid);
				} else {
					chatBox = createChatBoxFor(userid);
				}				
			}
			
			private function createChatBoxFor(userid:String):ChatBox {				
				var chatBox:ChatBox = new ChatBox();
				chatBox.id = getParticipantName(userid);
				LogUtil.debug("WATERFALL: chatBox.id = " + chatBox.id);
				chatBox.label = getParticipantName(userid);
				LogUtil.debug("WATERFALL: chatBox.label = " + chatBox.label);
				chatBox.name = userid;
				LogUtil.debug("WATERFALL: chatBox.name = " + chatBox.name);
				
				if (chatTabs.numChildren >= 2){ 
					chatTabs.addChildAt(chatBox, chatTabs.numChildren - 1);
				}
				else{
					chatTabs.addChild(chatBox);
				}
				//*
				var childIndex:int;
				childIndex = chatTabs.getChildIndex(chatBox);
				LogUtil.debug("WATERFALL: ChatBox is at index " + childIndex);
				if (childIndex == 0){
					//chatTabs.getChildAt(childIndex).parent.accessibilityProperties.name = PUBLIC_TAB + "NAME";
					this.accessibilityProperties.description = PUBLIC_TAB + "DESCRIPTION";
				}
				else if (childIndex == chatTabs.numChildren-1){
					this.accessibilityProperties.description = PLUS_TAB;
				}
				else{}
				
				Accessibility.updateProperties();
				//*/
				return chatBox;
			}
			
			private function createAddTabBox():AddChatTabBox{
				tabBox = new AddChatTabBox();
				tabBox.chatView = this;
				tabBox.id = TAB_BOX_ID;
				tabBox.label = TAB_BOX_ID;
				tabBox.name = TAB_BOX_ID;
				tabBox.chatOptions = chatOptions;
				chatTabs.addChild(tabBox);
				
				return tabBox;
			}
			
			// Receive public chat messages
			private function handlePublicChatMessageEvent(event:PublicChatMessageEvent):void {
				LogUtil.debug("Got PublicChatMessageEvent from userid [ " + event.chatobj.userid + " ]");
				showMessage(PUBLIC_CHAT_USERID, event.chatobj, autoTranslation);
				if ((! UserManager.getInstance().getConference().amIThisUser(new Number(event.chatobj.userid))) && (event.chatobj.userid != "")){
					if (Accessibility.active){
						publicNotification();
					}
					if (!this.focus){
						ExternalInterface.call("startblink", ResourceUtil.getInstance().getString('bbb.chat.publicMsgAwaiting'), ResourceUtil.getInstance().getString('bbb.chat.publicMsgAwaiting2'));
					}
				}
				globalDispatcher.dispatchEvent(new BBBEvent(BBBEvent.RECEIVED_PUBLIC_CHAT_MESSAGE_EVENT, event.chatobj.message));
			}
			
			// Receive private chat messages
			private function handlePrivateChatMessageEvent(event:PrivateChatMessageEvent):void {
				LogUtil.debug("Got PrivateChatMessageEvent");
				//LogUtil.debug("Message is from " + event.message.chatobj.username + ", user ID " + event.message.chatobj.userid);
				if ((! UserManager.getInstance().getConference().amIThisUser(new Number(event.message.chatobj.userid)))) {
					if (!this.focus){
						//LogUtil.debug("WATERFALL: About to make ExternalInterface Call");
						ExternalInterface.call("startblink", ResourceUtil.getInstance().getString('bbb.chat.privateMsgAwaiting'), ResourceUtil.getInstance().getString('bbb.chat.privateMsgAwaiting2'));
					}					
				}
				//LogUtil.debug("WATERFALL: Handling private message, about to showMessage");
				showMessage(event.message.sender, event.message.chatobj, autoTranslation);
				
				//LogUtil.debug("WATERFALL: About to add privateNotification");
				if (Accessibility.active){
					privateNotification(event);
				}
				
				/*// Trying to find the tab names
				var tabKids:Array = chatTabs.getChildren();
				LogUtil.debug("chatTabs has " + tabKids.length + "children.");
				for (var d:int = 0; d < tabKids.length; d++){
					LogUtil.debug("Name " + d + ": " + tabKids[d].name);
				}
				 */
			}
			
			// Activates an audio alert for screen-reader users on public message reception
			private function publicNotification():void{
				LogUtil.debug("Accessibility detected! Enabling public notifications.");
				publicWaiting = true;
				chatTabs.getChildByName("0").addEventListener(FocusEvent.FOCUS_IN, publicChatFocus);
			}
			
			public function publicChatFocus(event:FocusEvent):void{
				//LogUtil.debug("WATERFALL: publicChatFocus active, removing publicWaiting");
				if (publicWaiting)
					ExternalInterface.call("clearblink");
				publicWaiting = false;
			}
			
			// Activates an audio alert for screen-reader users on private message reception
			private function privateNotification(event:PrivateChatMessageEvent):void{
				if ((! UserManager.getInstance().getConference().amIThisUser(new Number(event.message.chatobj.userid)))) {
					var newItem:Boolean = true;
					// Check if there is already a notification of private messages from that user
					if (privateWaiting.length){
						for (var i:int = 0; i < privateWaiting.length; i++){
							// Compare userID of incoming message to userIDs of unsent notifications
							if (event.message.chatobj.userid == privateWaiting.getItemAt(i).message.chatobj.userid){
								newItem = false;
							}
						}
					}
					if (newItem){
						privateWaiting.addItem(event);
						chatTabs.getChildByName(event.message.chatobj.userid).addEventListener(FocusEvent.FOCUS_IN, privateChatFocus);
					}
				}
			}
			
			public function privateChatFocus(event:FocusEvent):void{
				//LogUtil.debug("WATERFALL: Event target is " + event.target);
				//LogUtil.debug("WATERFALL: Event target name is " + event.target.name);
				if (event.target.name == "chatMessagesList"){
					var messageCounter:int = -1;
					var removed:Boolean = false;
					do{
						messageCounter++;
						removed = removePrivateSender(event.target.parent.exposeSenderID(messageCounter));
						//LogUtil.debug("WATERFALL: messageCounter is " + messageCounter);
						//LogUtil.debug("WATERFALL: Trying to remove user " + event.target.parent.exposeSenderID(messageCounter));
					}while (!removed || messageCounter < event.target.parent.exposeNumMessages())
					if (removed){
						ExternalInterface.call("clearblink");
					}
				}
			}
			
			// Listens to the notification timer, and checks if there are messages waiting
			private function checkNotifications(event:TimerEvent):void{
				var debugDate:Date = new Date();
				if (publicWaiting){
					LogUtil.debug("The time is " + debugDate.getHours() + ":" + debugDate.getMinutes() + ":" + debugDate.getSeconds() + " and there are new public messages.");
            		publicSound.play();
				}
				
				// Clearing public notes works, but for some reason private chat tabs are not appearing
				// The tab appears on the second message you send
				if (privateWaiting.length){
					privateSound.play();
					/*LogUtil.debug("The time is " + debugDate.getHours() + ":" + debugDate.getMinutes() + ":" + debugDate.getSeconds() + " and there are new private messages from: ");
					for (var i:int = 0; i < privateWaiting.length; i++){
						LogUtil.debug(privateWaiting.getItemAt(i).message.chatobj.username);
					}*/
				}
			}
			
			private function playPublicSound():void{
				
			}
			
			private function playPrivateSound():void{
				
			}
			
			// Returns an array of userIDs. The userIDs refer to users who have sent this user private messages which have not been read.
			public function getPrivateSenders():ArrayCollection{
				var privateSenders:ArrayCollection = new ArrayCollection;
				if (privateWaiting.length){
					for (var i:int = 0; i < privateWaiting.length; i++){
						privateSenders.addItem(privateWaiting.getItemAt(i).message.chatobj.userid);
					}
				}
				return privateSenders;
			}
			
			private function removePrivateSender(senderID:String):Boolean{
				var success:Boolean = false;
				//LogUtil.debug("WATERFALL: Trying to remove sender " + senderID);
				if (privateWaiting.length){
					for (var i:int = 0; i < privateWaiting.length; i++){
						if (senderID == privateWaiting.getItemAt(i).message.chatobj.userid){
							privateWaiting.removeItemAt(i);
							success = true;
							i = privateWaiting.length;
							//LogUtil.debug("WATERFALL: Removed sender " + senderID);
						}
					}
				}
				return success;
			}
			
			/*
				// Descriptions for accessibilty properties
					private static const PUBLIC_TAB:String = "PUBLIC CHAT";
					private static const PUBLIC_TAB_NEW:String = "NEW MESSAGE IN PUBLIC CHAT";
					private static const PRIVATE_TAB:String = "PRIVATE CHAT WITH ";
					private static const PRIVATE_TAB_NEW:String = "NEW MESSAGE IN PRIVATE CHAT WITH ";
					private static const PLUS_TAB:String = "CHAT OPTIONS TAB";
			*/
			
			
			// All uses of updateTabNames temporarily disabled, as it is not working for mysterious reasons
			// It's intended use is to let a screen reader tell the user if there are new messages in the currently focused tab or not
			private function updateTabNames():void{
				LogUtil.debug("Entering updateTabNames");
				if (chatTabs.selectedIndex == 0){ // Public Chat tab
					LogUtil.debug("Entering public tab logic");
					if (publicWaiting){
						LogUtil.debug("Entering public waiting logic");
						this.accessibilityProperties.description = PUBLIC_TAB_NEW; 
					}
					else{
						LogUtil.debug("Entering public no-waiting logic");
						this.accessibilityProperties.description = PUBLIC_TAB;
					}
					LogUtil.debug("Leaving public logic");
				}
				else if (chatTabs.selectedIndex == chatTabs.numChildren - 1){ // Options tab
					LogUtil.debug("Entering options logic");
					this.accessibilityProperties.description = PLUS_TAB;
					LogUtil.debug("Leaving options logic");
				}
				else{ // Any Private Chat tab
					LogUtil.debug("Entering private logic");
					var otherUserID:String = chatTabs.getChildAt(chatTabs.selectedIndex).name;
					var otherUserName:String = UserManager.getInstance().getConference().getParticipant(int(otherUserID)).name;
					LogUtil.debug("WATERFALL: Just to be sure, user ID " + otherUserID + " has the name " + otherUserName);
					if (getPrivateSenders().contains(otherUserID)){ // New messages
						LogUtil.debug("Entering private new-message logic");
						this.accessibilityProperties.description = PRIVATE_TAB_NEW + otherUserName;
						LogUtil.debug("Leaving private new-message logic");
					}
					else{ // No new messages
						LogUtil.debug("Entering private no-new-message logic");
						this.accessibilityProperties.description = PRIVATE_TAB + otherUserName;
						LogUtil.debug("Leaving private no-new-message logic");
					}
					LogUtil.debug("Leaving private logic");
				}
				Accessibility.updateProperties();
				//focusManager.setFocus(this);
				LogUtil.debug("WATERFALL: Description is now: "+ this.accessibilityProperties.description);
				LogUtil.debug("Leaving updateTableNames");
			}
			
			// About to change description again
			// From (chatTabs.selectedIndex).accessibilityProperties.description
			// To this.accessibilityProperties.description
			
			private function focusPreviousChatTab(e:ShortcutEvent):void{
				if (chatTabs.selectedIndex > 0){
					chatTabs.selectedIndex--;
				}
				else{
					chatTabs.selectedIndex = chatTabs.numChildren - 1;
				}
				//updateTabNames();				
			}
			
			private function focusNextChatTab(e:ShortcutEvent):void{
				if (chatTabs.selectedIndex < chatTabs.numChildren - 1){
					chatTabs.selectedIndex++;
				}
				else{
					chatTabs.selectedIndex = 0;
				}
				//updateTabNames();
			}
			
			private function participantHasChatBox(id:String):Boolean {
				var chatBox:ChatBox = chatTabs.getChildByName(id) as ChatBox;
				if (chatBox != null) return true;
				return false;
			}
			
			private function getChatBoxForParticipant(id:String):ChatBox {
				return chatTabs.getChildByName(id) as ChatBox;
			}
            
			/* it should receive the ChatObject */
			private function showMessage(sender:String, chatobj:ChatObject, translate:Boolean):void{
				var chatBox:ChatBox;
				if (! participantHasChatBox(sender)) {
					chatBox = createChatBoxFor(sender);
				}
				
				chatBox = getChatBoxForParticipant(sender);
				chatBox.showNewMessage(chatobj, translate, ResourceUtil.getInstance().getCurrentLanguageCode().split("_")[0]);
				
				if (! isChatBoxCurrentlySelected(sender)) {
					notifyParticipantOfUnreadMessageFrom(sender);
				}				
			}
			
			public function changeFontSize(e:ChatOptionsEvent):void{
                chatWindow.txtMsg.setStyle("fontSize", e.fontSize);
			}
			
			private function onTabClose(e:SuperTabEvent):void{
				dispatchEvent(e);
			}
			
			private function onUserClosedTab(e:SuperTabEvent):void{
				var name:String = chatTabs.getChildAt(e.tabIndex).name;
			}
			
			private function enableMessageEntryTextBox():void {
                chatWindow.txtMsg.enabled = true;
			}
			
			private function disableMessageEntryTextBox():void {
                chatWindow.txtMsg.enabled = false;
			}
			
			/** Inherited from IUserListener */
			public function presenterChanged(newPresenter:User):void{
				
			}
			
			public function userJoined(user:User):void{
				addParticipantToList(user.userid, user.name, user.role);
			}
			
			public function userLeft(user:User):void{
				removeParticipantFromList(user.userid);
			}
			/** end IUserListener methods */
			
			private function toggleTranslation(e:ChatOptionsEvent):void
			{
				this.autoTranslation = e.translateOn;
			}
						
		]]>
	</mx:Script>
	<containers:SuperTabNavigator id="chatTabs" width="100%" height="100%" change="onTabNavChange()" tabClose="onTabClose(event)" minTabWidth="20"
								  dragEnabled="false" popUpButtonPolicy="off"/>
</mx:VBox>
