<?xml version="1.0" encoding="utf-8"?>

<!--
  BigBlueButton open source conferencing system - http://www.bigbluebutton.org
  
  Copyright (c) 2010 BigBlueButton Inc. and by respective authors (see below).
  
  BigBlueButton is free software; you can redistribute it and/or modify it under the 
  terms of the GNU Lesser General Public License as published by the Free Software 
  Foundation; either version 2.1 of the License, or (at your option) any later 
  version. 
  
  BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY 
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
  PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License along 
  with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 
  $Id: $
-->

<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" width="100%" height="100%" xmlns:mate="http://mate.asfusion.com/"
	mouseDown="doMouseDown()" mouseMove="doMouseMove()" mouseUp="doMouseUp()" creationComplete="init()" visible="false" 
	mouseOver="setCursor()" mouseOut="removeCursor()" implements="org.bigbluebutton.common.IBbbCanvas">
	<mx:Script>
		<![CDATA[			
			import mx.collections.ArrayCollection;
			import mx.core.Application;
			import mx.managers.CursorManager;
			
			import org.bigbluebutton.common.IBbbCanvas;
			import org.bigbluebutton.common.Images;
			import org.bigbluebutton.common.LogUtil;
			import org.bigbluebutton.modules.present.events.WindowResizedEvent;
			import org.bigbluebutton.modules.whiteboard.business.shapes.DrawObject;
			import org.bigbluebutton.modules.whiteboard.business.shapes.DrawObjectFactory;
			import org.bigbluebutton.modules.whiteboard.business.shapes.ShapeFactory;
			import org.bigbluebutton.modules.whiteboard.events.PageEvent;
			import org.bigbluebutton.modules.whiteboard.events.WhiteboardButtonEvent;
			import org.bigbluebutton.modules.whiteboard.events.WhiteboardDrawEvent;
			import org.bigbluebutton.modules.whiteboard.events.WhiteboardPresenterEvent;
			import org.bigbluebutton.modules.whiteboard.events.WhiteboardUpdate;
			import org.bigbluebutton.modules.whiteboard.maps.WhiteboardEventMap;
			
			private var x1:int;
			private var y1:int;
			private var x2:int; 
			private var y2:int;
			
			private var isDrawing:Boolean; 
			private var sending:Boolean = false;
			private var feedback:Shape = new Shape();
			private var latentFeedbacks:ArrayCollection = new ArrayCollection();
			private var segment:Array = new Array();
			private var shapeList:Array = new Array();
			
			protected var shapeFactory:ShapeFactory = new ShapeFactory();
			protected var bbbCanvas:IBbbCanvas;
		
			protected var shapeStyle:String = DrawObject.PENCIL;
			protected var drawColor:uint = 0x000000;
			protected var thickness:uint = 1;
			
			private var _xPosition:int;
			private var _yPosition:int;
			
			private var images:Images = new Images();
			[Bindable] private var pencil_icon:Class = images.pencil_icon;
			
			private var whiteboardEnabled:Boolean = false;
			private var showWhiteboard:Boolean = true;
			
			private var drawTimer:Timer;
			
			private function init():void{
				this.label = "Highlighter";
			}
			
			/**
			*Method is invoked when the mouse is released
			*<p>
			*The method finalizes the shape that was being edited. The shape is then sent as 
			*an event, which updates all client views.  
			*<p>
			*The method also deleted the temporary feedback shape from the screen.
			*/
			private function doMouseUp():void{
				if (isDrawing) {
					/**
					 * Check if we are drawing because when resizing the window, it generates
					 * a mouseUp event at the end of resize. We don't want to dispatch another
					 * shape to the viewers.
					 */
					isDrawing = false;
					sendShapeToServer(false);
				}
			}
			
			private var objCount:int = 0;
			
			private function sendShapeToServer(update:Boolean):void{
				if (segment.length == 0) return;
				
				var dobj:DrawObject = shapeFactory.createDrawObject(this.shapeStyle, segment, this.drawColor, this.thickness);
				
				this.addRawChild(dobj.getShape());
				var rect:Rectangle = dobj.getShape().getBounds(this);
				this.removeRawChild(dobj.getShape());
				LogUtil.debug("*** Shape [" + dobj.getShape().width + " , " + dobj.getShape().height + "] [" +  dobj.getShape().x + " , " + dobj.getShape().y + "]");
				LogUtil.debug("*** Bounds [" + rect.width + " , " + rect.height + "] [" +  rect.x + " , " + rect.y + "]");

				dobj.width = (rect.width / this.width) * 100;
				dobj.x = (rect.x / this.width) * 100;
				dobj.height = (rect.height / this.height) * 100;
				dobj.y = (rect.y / this.height) * 100;
				
//				dobj.width = (dobj.getShape().width / this.width) * 100;
//				dobj.x = (dobj.getShape().x / this.width) * 100;
//				dobj.height = (dobj.getShape().height / this.height) * 100;
//				dobj.y = (dobj.getShape().y / this.height) * 100;
				
//				var date:Date = new Date();
//				dobj.id = date.time.toString();
								
				dobj.id = "" + objCount++;

				LogUtil.debug("*** SEND Display Container [" + dobj.id + "][" + this.width + " , " + this.height + "," +  this.x + " , " + this.y + "]");
				LogUtil.debug("*** Send shape [" + dobj.id + "][" + dobj.width + " , " + dobj.height + "] [" +  dobj.x + " , " + dobj.y + "]"); 
				
/*				
				if (update) {
					dobj.status = "UPDATE";
					if (this.shapeStyle == DrawObject.PENCIL) {
			//			var startX:Number = segment[segment.length - 2] as Number;
			//			var startY:Number = segment[segment.length - 1] as Number;
						segment = new Array();						
						segment.push(this.mouseX);
						segment.push(this.mouseY);
					}					
				} else {					
					dobj.status = "END";
				}
*/				
				var event:WhiteboardDrawEvent = new WhiteboardDrawEvent(WhiteboardDrawEvent.SEND_SHAPE);
				event.message = dobj;
				dispatchEvent(event);				
			}
			
			/**
			*Method is invoked when the mouse is pressed
			*<p>
			*The method captures the x and y coordinates of the mouse click and uses the point as
			*the starting point in a shape
			*/
			private function doMouseDown():void{
				isDrawing = true;
				segment = new Array();
				segment.push(this.mouseX);
				segment.push(this.mouseY);
			}
						
			/**
			*Method is invoked when the mouse is moved over the canvas
			*<p>
			*The method captures the x and y coordinates of the mouse, adding the points to the current
			*shape being drawn. 
			*<p>
			*Note: The method only works if the mouse is pressed, otherwise does nothing.
			*/
			private function doMouseMove():void{
				if (isDrawing){
					segment.push(this.mouseX);
					segment.push(this.mouseY);
//					if (segment.length > 100) sendShapeToServer(true);
				}
			}
			
			/**
			 * Draws the segment stored in the drawVO Value Object
			 * <p>
			 * This method is executed by the BoardMediator upon reception of an Update request. The method
			 * is executed on all clients, even the one which sent the update request.
			 */
			public function drawSegment(event:WhiteboardUpdate):void{
				var o:DrawObject = event.data;
				draw(o);
			}
			
			private function draw(o:DrawObject):void{
//				for( var i:int = 0; i < latentFeedbacks.length;i++){
//					var tempshape:Shape = latentFeedbacks.getItemAt(i) as Shape;
//					if(rawChildren.contains(tempshape))
//					{
//						rawChildren.removeChild(tempshape);
//						latentFeedbacks.removeItemAt(i);
//					}
//				}

				
				LogUtil.debug("*** Rx shape [" + o.id + "][" + o.width + " , " + o.height + "] [" +  o.x + " , " + o.y + "]");
				var dobj:DrawObject = shapeFactory.makeShape(o);
				var newShape:Shape = dobj.getShape();
				bbbCanvas.addRawChild(newShape);
				var rect:Rectangle = newShape.getBounds(this);
				/* No need to set the size as we already adjusted the points for this canvas size */
//				newShape.width = ((dobj.width/100) * this.width);
//				newShape.height = ((dobj.height/100) * this.height);
//				newShape.x = ((dobj.x/100) * this.width);
//				newShape.y = ((dobj.y/100) * this.height);

//				dobj.width = rect.width;
//				dobj.height = rect.height;
//				dobj.x = rect.x;
//				dobj.y = rect.y;
				rect.width = ((dobj.width/100.0) * Number(width));
				rect.height = ((dobj.height/100.0) * Number(height));
				rect.x = ((dobj.x/100.0) * width as Number);
				rect.y = ((dobj.y/100.0) * Number(height));
//				rect.x = (0.5 * width as Number);
//				rect.y = (0.5 * Number(height));
				LogUtil.debug("*** Display Rx shape [" + dobj.id + "][" + dobj.width + " , " + dobj.height + "] [" +  dobj.x + " , " + dobj.y + "]");
				LogUtil.debug("*** Display Rx new shape [" + dobj.id + "][" + newShape.width + " , " + newShape.height + "] [" +  newShape.x + " , " + newShape.y + "]");
				LogUtil.debug("*** Display Rx rect shape [" + dobj.id + "][" + rect.width + " , " + rect.height + "] [" +  rect.x + " , " + rect.y + "]");
				LogUtil.debug("*** RX Display Container [" + dobj.id + "][" + this.width + " , " + this.height + "," +  this.x + " , " + this.y + "]");
				
	            shapeList.push(dobj);	            
			}
			
			/**
			 * Sets the type of shape we're drawing (pencil, rectangle, etc...) 
			 * @param s The type
			 * 
			 */		
			public function setShape(s:String):void{
				this.shapeStyle = s;
			}
			
			/**
			 * Sets the color 
			 * @param e event containing the color (e.target.selectedColor)
			 * 
			 */		
			public function changeColor(e:Event):void{
				drawColor = e.target.selectedColor;
			}
			
			/**
			 * Sets the thickness 
			 * @param e event containing the thickness (e.target.value)
			 * 
			 */		
			public function changeThickness(e:Event):void{
				this.thickness = e.target.value;
			}
			
			/**
			 * Clears the entire board
			 */
			public function clearBoard(event:WhiteboardUpdate = null):void{
				for (var i:Number = 0; i < this.shapeList.length; i++){
					var dobj:DrawObject = this.shapeList[i] as DrawObject;
					if (this.doesContain(dobj.getShape())){
						this.removeRawChild(dobj.getShape());	
					}
				}
				this.shapeList = new Array();
			}
			
			public function undoShape(event:WhiteboardUpdate):void{
				if (this.shapeList.length > 0) {
					var dobj:DrawObject = this.shapeList[this.shapeList.length-1] as DrawObject;
					this.removeRawChild(dobj.getShape());
					shapeList.pop();
				}
			}
			
			public function get xPosition():int {
				return _xPosition;
			}
			
			public function get yPosition():int {
				return _yPosition;
			}
			
			public function set xPosition(x:int):void {
				_xPosition = x;
			}
			
			public function set yPosition(y:int):void {
				_yPosition = y;
			}
						
			private function changePage(e:PageEvent):void{
				var page:Number = e.pageNum;
				var shapes:ArrayCollection = e.shapes;
				clearBoard();
				for (var i:int = 0; i < shapes.length; i++){
					var o:DrawObject = shapes.getItemAt(i) as DrawObject;
					draw(o);
				}
			}
			
			private function setWhiteboardVisibility():void{
				if (this.whiteboardEnabled && this.showWhiteboard) this.visible = true;
				else this.visible = false;
			}
			
			private function setCursor():void{
				CursorManager.setCursor(pencil_icon);
			}
			
			private function removeCursor():void{
				CursorManager.removeCursor(CursorManager.currentCursorID);
				doMouseUp();
			}
			
			/** Inherited from org.bigbluebutton.common.IBbbCanvas*/
			public function addRawChild(child:DisplayObject):void{
				this.rawChildren.addChild(child);
			}
			
			public function removeRawChild(child:DisplayObject):void{
				this.rawChildren.removeChild(child);
			}
			
			public function doesContain(child:DisplayObject):Boolean{
				return this.rawChildren.contains(child);
			}
			
			public function acceptOverlayCanvas(overlay:IBbbCanvas):void{
				LogUtil.debug("WhiteboardCanvas::acceptOverlayCanvas()");
				this.bbbCanvas = overlay;
				//Load existing shapes onto the canvas.
				dispatchEvent(new PageEvent(PageEvent.LOAD_PAGE));
			}
			
			public function moveCanvas(x:Number, y:Number):void{
				this.x = x;
				this.y = y;
			}
					
			public function zoomCanvas(width:Number, height:Number):void{
				shapeFactory.setParentDim(width, height);	
				
				/**
				 * Let's be careful on the sequence of actions we do here.
				 * 1. Adjust the size of the canvas.
				 * 2. Calculate the width and height of the shape. This will change the
				 *    x and y coordinate of the shape.
				 * 3. Force the x and y coordinate to be where we want it to be.
				 */
				
				var oldW:int = this.width;
				var oldH:int = this.height;
				/* 1. Adjust the size of the canvas. */
				this.width = width;
				this.height = height;
				
				for (var i:int = 0; i < this.shapeList.length; i++){
					var dobj:DrawObject = this.shapeList[i] as DrawObject;
					var s:Shape = dobj.getShape();
//					s.scaleX = (width/this.width);
//					s.scaleY = (height/this.height);
//					/* 2. Calculate the width and height which changes the x and y coordinate of the shape. */
					s.width = ((dobj.width/100.0) * Number(width));
					s.height = ((dobj.height/100.0) * Number(height));
//					var newW:int = ((dobj.width/100.0) * Number(width));
//					if (s.width >= 1) 
//						s.width = newW;
//					var newH:int = ((dobj.height/100.0) * Number(height));
//					if (s.height >= 1)
//						s.height = newH;
//					/* 3. Force the x and y to where we want the shape */
//					s.x = ((dobj.x/100.0) * width as Number) + this.x;
//					s.y = ((dobj.y/100.0) * Number(height)) + this.y;
					
					LogUtil.debug("*** Display Container [" + dobj.id + "][" + this.width + "," + this.height + "," +  this.x + " , " + this.y + "]");
					LogUtil.debug("*** Display Resize shape [" + dobj.id + "][" + s.width + " , " + s.height + "] [" +  s.x + " , " + s.y + "]");
					
					
					var rect:Rectangle = s.getBounds(this);
//					rect.width *= (this.width/oldW);
//					rect.height *= (this.height/oldH);
//					rect.x *= (this.width/oldW);
//					rect.y *= (this.height/oldH);
//					rect.width = (dobj.width/100) * width;
//					rect.height = (dobj.height/100) * height;
					rect.x = (dobj.x/100) * width + this.x;
					rect.y = (dobj.y/100) * height + this.y;
//					rect.x += this.x;
//					rect.y += this.y;
					
				LogUtil.debug("*** Display Resize shape [" + dobj.id + "][" + rect.width + " , " + rect.height + "] [" +  rect.x + " , " + rect.y + "]");

				}
			//					this.width = width;
			//					this.height = height;
				
			}
					
			public function showCanvas(show:Boolean):void{
				this.showWhiteboard = show;
				setWhiteboardVisibility();
			}
			
			/** End IBBBCanvas*/
			
			public function isPageEmpty():Boolean{
				return (this.shapeList.length == 0);
			}
			
			private function enableWhiteboard(e:WhiteboardButtonEvent):void{
				this.whiteboardEnabled = true;
				setWhiteboardVisibility();
			}
			
			private function disableWhiteboard(e:WhiteboardButtonEvent):void{
				this.whiteboardEnabled = false;
				setWhiteboardVisibility();
			}
			
		]]>
	</mx:Script>
	
	<mate:Debugger level="{Debugger.ALL}" />
	<mate:Listener type="{WhiteboardUpdate.BOARD_CLEARED}" method="clearBoard" />
	<mate:Listener type="{WhiteboardUpdate.BOARD_UPDATED}" method="drawSegment" />
	<mate:Listener type="{WhiteboardUpdate.SHAPE_UNDONE}" method="undoShape" />
	<mate:Listener type="{PageEvent.CHANGE_PAGE}" method="changePage" />
	<mate:Listener type="{WhiteboardButtonEvent.ENABLE_WHITEBOARD}" method="enableWhiteboard" />
	<mate:Listener type="{WhiteboardButtonEvent.DISABLE_WHITEBOARD}" method="disableWhiteboard" />
</mx:Canvas>
