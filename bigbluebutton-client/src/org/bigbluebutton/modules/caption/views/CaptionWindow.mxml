<?xml version="1.0" encoding="utf-8"?>
<!--

BigBlueButton open source conferencing system - http://www.bigbluebutton.org/

Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).

This program is free software; you can redistribute it and/or modify it under the
terms of the GNU Lesser General Public License as published by the Free Software
Foundation; either version 3.0 of the License, or (at your option) any later
version.

BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.

-->

<CustomMdiWindow xmlns="org.bigbluebutton.common.*" 
			xmlns:mx="http://www.adobe.com/2006/mxml"
			implements="org.bigbluebutton.common.IBbbModuleWindow"
			title="Closed Caption"
			width="400" height="300"
			showCloseButton="false"
			creationComplete="onCreationComplete()" xmlns:views="org.bigbluebutton.modules.caption.views.*">
	<mx:Script>
		<![CDATA[
			import com.asfusion.mate.events.Dispatcher;
			
			import mx.binding.utils.ChangeWatcher;
			import mx.events.FlexEvent;
			
			import org.bigbluebutton.main.views.MainCanvas;
			import org.bigbluebutton.modules.caption.events.RequestTranscriptsEvent;
			import org.bigbluebutton.modules.caption.events.SendEditCaptionHistoryEvent;
			import org.bigbluebutton.modules.caption.model.Transcript;
			import org.bigbluebutton.modules.caption.model.Transcripts;
			
			private var transcripts:Transcripts;
			private var currentTranscript:Transcript;
			private var transcriptChangeWatcher:ChangeWatcher;
			
			private var _checkForOverwrite:Boolean = false;
			private var _checkForDeletePreviousWord:Boolean = false;
			private var _checkForDeleteNextWord:Boolean = false;
			private var _lastTextInput:String;
			private var _lastTextLength:int;
			private var _lastSelectionIndex:int;
			
			private function onCreationComplete():void {
				var requestTranscripts:RequestTranscriptsEvent = new RequestTranscriptsEvent(RequestTranscriptsEvent.REQUEST_TRANSCRIPTS_EVENT);
				requestTranscripts.callback = setTranscripts;
				var dispatcher:Dispatcher = new Dispatcher();
				dispatcher.dispatchEvent(requestTranscripts);
				
				onFontSizeComboChange();
				onFontTypeComboChange();
				
				transcriptArea.getInternalTextField().addEventListener(KeyboardEvent.KEY_DOWN, onTranscriptKeyDown);
				outputArea.getInternalTextField().type = TextFieldType.DYNAMIC;
			}
			
			private function setTranscripts(t:Transcripts):void {
				transcripts = t;
				onLocaleComboChange();
				if (!t.historyIntited) {
					t.historyInitCallback = handleHistoryInitialized;
				}
			}
			
			private function handleHistoryInitialized():void {
				onLocaleComboChange();
			}
			
			public function getPrefferedPosition():String {
				return MainCanvas.POPUP;
			}
			
			private function onTranscriptChange(event:Event):void {
				refreshTextArea();
			}
			
			private function refreshTextArea(refreshInputArea:Boolean=false):void {
				outputArea.text = currentTranscript.transcript;
				if (refreshInputArea){
					transcriptArea.text = currentTranscript.transcript;
				}
			}
			
			private function onFontSizeComboChange():void {
				transcriptArea.setStyle("fontSize", int(fontSizeCombo.selectedItem));
				outputArea.setStyle("fontSize", int(fontSizeCombo.selectedItem));
			}
			
			private function onFontTypeComboChange():void {
				transcriptArea.setStyle("fontFamily", fontTypeCombo.selectedItem);
				outputArea.setStyle("fontFamily", fontTypeCombo.selectedItem);
			}
			
			private function onLocaleComboChange():void {
				if (transcripts) {
					if (currentTranscript) {
						currentTranscript.removeEventListener(Event.CHANGE, onTranscriptChange);
					}
					currentTranscript = transcripts.findLocale(localeCombo.selectedLabel);
					currentTranscript.addEventListener(Event.CHANGE, onTranscriptChange);
					refreshTextArea(true);
				}
			}
			
			private function onTranscriptTextInput(e:TextEvent):void {
				trace("Text entered: " + e.text + ", carat begin:" + transcriptArea.selectionBeginIndex + ", end: " + transcriptArea.selectionEndIndex);
				
				// There is no surefire way to detect whether the internal TextField is in overwrite mode or not. We need to 
				// delay sending the message until after the text changes and then check length. This extra check is only 
				// required if the input is length 1 and nothing is selected because it would be a simple replace otherwise.
				if (e.text.length == 1 && transcriptArea.selectionBeginIndex == transcriptArea.selectionEndIndex) {
					_checkForOverwrite = true;
					_lastTextInput = e.text;
					_lastTextLength = transcriptArea.text.length;
				} else {
					respondToTextChange(e.text, transcriptArea.selectionBeginIndex, transcriptArea.selectionEndIndex);
				}
			}
			
			private function onTranscriptTextChange(e:Event):void {
				trace("transcript change: " + transcriptArea.text);
				
				if (_checkForOverwrite) {
					_checkForOverwrite = false;
					if (transcriptArea.text.length > _lastTextLength) { // not an overwrite
						respondToTextChange(_lastTextInput, transcriptArea.selectionBeginIndex-1, transcriptArea.selectionEndIndex-1);
					} else {											// an overwrite
						respondToTextChange(_lastTextInput, transcriptArea.selectionBeginIndex-1, transcriptArea.selectionEndIndex);
					}
					_lastTextInput = null;
					_lastTextLength = 0;
				} else if (_checkForDeletePreviousWord) {
					_checkForDeletePreviousWord = false;
					respondToTextChange("", _lastSelectionIndex-(_lastTextLength-transcriptArea.text.length), _lastSelectionIndex);
					_lastSelectionIndex = 0;
					_lastTextLength = 0;
				} else if (_checkForDeleteNextWord) {
					_checkForDeleteNextWord = false;
					respondToTextChange("", _lastSelectionIndex, _lastSelectionIndex+(_lastTextLength-transcriptArea.text.length));
					_lastSelectionIndex = 0;
					_lastTextLength = 0;
				}
			}
			
			private function onTranscriptDataChange(e:FlexEvent):void {
				trace("transcript change");
			}
			
			private function onTranscriptKeyDown(e:KeyboardEvent):void {
				// TODO: Need to make sure I handle the CTRL, SHIFT, and ALT cases because they are different
				var si:int = transcriptArea.selectionBeginIndex;
				var ei:int = transcriptArea.selectionEndIndex;
				switch (e.keyCode) {
					case Keyboard.BACKSPACE:
						if (e.ctrlKey || e.altKey) {
							_lastSelectionIndex = ei;
							_lastTextLength = transcriptArea.text.length;
							_checkForDeletePreviousWord = true;
							return;
						}
						if (si == ei) {
							if (si == 0) {
								return;
							}
							si--;
						}
						respondToTextChange("", si, ei);
						break;
					case Keyboard.DELETE:
						if (e.ctrlKey || e.altKey) {
							_lastSelectionIndex = si;
							_lastTextLength = transcriptArea.text.length;
							_checkForDeleteNextWord = true;
							return;
						}
						if (si == ei) {
							if (si == transcriptArea.length+1) {
								return ;
							}
							ei++;
						}
						respondToTextChange("", si, ei);
						break;
					case Keyboard.X:
						if (e.ctrlKey) {
							if (si != ei) {
								respondToTextChange("", si, ei);
							}
						}
						break;
				}
			}
			
			private function respondToTextChange(t:String, si:int, ei:int):void {
				var editHistoryEvent:SendEditCaptionHistoryEvent = new SendEditCaptionHistoryEvent(SendEditCaptionHistoryEvent.SEND_EDIT_CAPTION_HISTORY);
				editHistoryEvent.locale = localeCombo.selectedLabel;
				editHistoryEvent.startIndex = si;
				editHistoryEvent.endIndex = ei;
				editHistoryEvent.text = t;
				
				var dispatcher:Dispatcher = new Dispatcher();
				dispatcher.dispatchEvent(editHistoryEvent);
			}
		]]>
	</mx:Script>
	<mx:VBox width="100%" height="100%" horizontalAlign="left">
		<mx:HBox width="100%">
			<mx:ComboBox id="fontSizeCombo" dataProvider="[8, 10, 12, 14, 16]" selectedIndex="2" change="onFontSizeComboChange()"/>
			<mx:ColorPicker id="fontColorPicker" />
			<mx:ComboBox id="fontTypeCombo" dataProvider="['Arial', 'Calibri', 'Time New Roman', 'Comic Sans']" change="onFontTypeComboChange()"/>
			<mx:ComboBox id="localeCombo" dataProvider="['en_US','ca_FR', 'pt_PT']" change="onLocaleComboChange()"/>
		</mx:HBox>
		<mx:Label text="Input:" />
		<views:TextArea2 id="transcriptArea" width="100%" height="100%" textInput="onTranscriptTextInput(event)" change="onTranscriptTextChange(event)" dataChange="onTranscriptDataChange(event)" />
		<mx:Label text="Output:" />
		<views:TextArea2 id="outputArea" width="100%" height="100%" />
	</mx:VBox>
</CustomMdiWindow>
